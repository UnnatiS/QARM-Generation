Availability: Availability defines the proportion of time that the system is functional and working
It can be measured as a percentage of the total system downtime over a predefined period

Availability will be affected by system errors, infrastructure problems, malicious attacks, and system load

The key issues for availability are A physical tier such as the database server or application server can fail or become unresponsive, causing the entire system to fail

Consider how to design failover support for the tiers in the system

For example, use Network Load Balancing for Web servers to distribute the load and prevent requests being directed to a server that is down

Also, consider using a RAID mechanism to mitigate system failure in the event of a disk failure

Consider if there is a need for a geographically separate redundant site to failover to in case of natural disasters such as earthquakes or tornados

Denial of Service (DoS) attacks, which prevent authorized users from accessing the system, can interrupt operations if the system cannot handle massive loads in a timely manner, often due to the processing time required, or network configuration and congestion

To minimize interruption from DoS attacks, reduce the attack surface area, identify malicious behavior, use application instrumentation to expose unintended behavior, and implement comprehensive data validation

Consider using the Circuit Breaker or Bulkhead patterns to increase system resiliency

Inappropriate use of resources can reduce availability

For example, resources acquired too early and held for too long cause resource starvation and an inability to handle additional concurrent user requests

Bugs or faults in the application can cause a system wide failure

Design for proper exception handling in order to reduce application failures from which it is difficult to recover

Frequent updates, such as security patches and user application upgrades, can reduce the availability of the system

Identify how you will design for run-time upgrades

A network fault can cause the application to be unavailable

Consider how you will handle unreliable network connections; for example, by designing clients with occasionally-connected capabilities

Consider the trust boundaries within your application and ensure that subsystems employ some form of access control or firewall, as well as extensive data validation, to increase resiliency and availability

$$ Conceptual Integrity: Conceptual integrity defines the consistency and coherence of the overall design

This includes the way that components or modules are designed, as well as factors such as coding style and variable naming

A coherent system is easier to maintain because you will know what is consistent with the overall design

Conversely, a system without conceptual integrity will constantly be affected by changing interfaces, frequently deprecating modules, and lack of consistency in how tasks are performed

The key issues for conceptual integrity are: Mixing different areas of concern within your design

Consider identifying areas of concern and grouping them into logical presentation, business, data, and service layers as appropriate

Inconsistent or poorly managed development processes

Consider performing an Application Lifecycle Management (ALM) assessment, and make use of tried and tested development tools and methodologies

Lack of collaboration and communication between different groups involved in the application lifecycle

Consider establishing a development process integrated with tools to facilitate process workflow, communication, and collaboration

Lack of design and coding standards

Consider establishing published guidelines for design and coding standards, and incorporating code reviews into your development process to ensure guidelines are followed

Existing (legacy) system demands can prevent both refactoring and progression toward a new platform or paradigm

Consider how you can create a migration path away from legacy technologies, and how to isolate applications from external dependencies

For example, implement the Gateway design pattern for integration with legacy systems

$$ Interoperability: Interoperability is the ability of a system or different systems to operate successfully by communicating and exchanging information with other external systems written and run by external parties

An interoperable system makes it easier to exchange and reuse information internally as well as externally

Communication protocols, interfaces, and data formats are the key considerations for interoperability

Standardization is also an important aspect to be considered when designing an interoperable system

The key issues for interoperability are: Interaction with external or legacy systems that use different data formats

Consider how you can enable systems to interoperate, while evolving separately or even being replaced

For example, use orchestration with adaptors to connect with external or legacy systems and translate data between systems; or use a canonical data model to handle interaction with a large number of different data formats

Boundary blurring, which allows artifacts from one system to defuse into another

Consider how you can isolate systems by using service interfaces and/or mapping layers

For example, expose services using interfaces based on XML or standard types in order to support interoperability with other systems

Design components to be cohesive and have low coupling in order to maximize flexibility and facilitate replacement and reusability

Lack of adherence to standards

Be aware of the formal and de facto standards for the domain you are working within, and consider using one of them rather than creating something new and proprietary

$$ Maintainability: Maintainability is the ability of the system to undergo changes with a degree of ease

These changes could impact components, services, features, and interfaces when adding or changing the application’s functionality in order to fix errors, or to meet new business requirements

Maintainability can also affect the time it takes to restore the system to its operational status following a failure or removal from operation for an upgrade

Improving system maintainability can increase availability and reduce the effects of run-time defects

An application’s maintainability is often a function of its overall quality attributes but there a number of key issues that can directly affect maintainability: Excessive dependencies between components and layers, and inappropriate coupling to concrete classes, prevents easy replacement, updates, and changes; and can cause changes to concrete classes to ripple through the entire system

Consider designing systems as well-defined layers, or areas of concern, that clearly delineate the system’s UI, business processes, and data access functionality

Consider implementing cross-layer dependencies by using abstractions (such as abstract classes or interfaces) rather than concrete classes, and minimize dependencies between components and layers

The use of direct communication prevents changes to the physical deployment of components and layers

Choose an appropriate communication model, format, and protocol

Consider designing a pluggable architecture that allows easy upgrades and maintenance, and improves testing opportunities, by designing interfaces that allow the use of plug-in modules or adapters to maximize flexibility and extensibility

Reliance on custom implementations of features such as authentication and authorization prevents reuse and hampers maintenance

To avoid this, use the built-in platform functions and features wherever possible

The logic code of components and segments is not cohesive, which makes them difficult to maintain and replace, and causes unnecessary dependencies on other components

Design components to be cohesive and have low coupling in order to maximize flexibility and facilitate replacement and reusability

The code base is large, unmanageable, fragile, or over complex; and refactoring is burdensome due to regression requirements

Consider designing systems as well defined layers, or areas of concern, that clearly delineate the system’s UI, business processes, and data access functionality

Consider how you will manage changes to business processes and dynamic business rules, perhaps by using a business workflow engine if the business process tends to change

Consider using business components to implement the rules if only the business rule values tend to change; or an external source such as a business rules engine if the business decision rules do tend to change

The existing code does not have an automated regression test suite

Invest in test automation as you build the system

This will pay off as a validation of the system’s functionality, and as documentation on what the various parts of the system do and how they work together

Lack of documentation may hinder usage, management, and future upgrades

Ensure that you provide documentation that, at minimum, explains the overall structure of the application

$$ Manageability: Manageability defines how easy it is for system administrators to manage the application, usually through sufficient and useful instrumentation exposed for use in monitoring systems and for debugging and performance tuning

Design your application to be easy to manage, by exposing sufficient and useful instrumentation for use in monitoring systems and for debugging and performance tuning

The key issues for manageability are: Lack of health monitoring, tracing, and diagnostic information

Consider creating a health model that defines the significant state changes that can affect application performance, and use this model to specify management instrumentation requirements

Implement instrumentation, such as events and performance counters, that detects state changes, and expose these changes through standard systems such as Event Logs, Trace files, or Windows Management Instrumentation (WMI)

Capture and report sufficient information about errors and state changes in order to enable accurate monitoring, debugging, and management

Also, consider creating management packs that administrators can use in their monitoring environments to manage the application

Lack of runtime configurability

Consider how you can enable the system behavior to change based on operational environment requirements, such as infrastructure or deployment changes

Lack of troubleshooting tools

Consider including code to create a snapshot of the system’s state to use for troubleshooting, and including custom instrumentation that can be enabled to provide detailed operational and functional reports

Consider logging and auditing information that may be useful for maintenance and debugging, such as request details or module outputs and calls to other systems and services

$$ Performance: Performance is an indication of the responsiveness of a system to execute specific actions in a given time interval

It can be measured in terms of latency or throughput

Latency is the time taken to respond to any event

Throughput is the number of events that take place in a given amount of time

An application’s performance can directly affect its scalability, and lack of scalability can affect performance

Improving an application’s performance often improves its scalability by reducing the likelihood of contention for shared resources

Factors affecting system performance include the demand for a specific action and the system’s response to the demand

The key issues for performance are: Increased client response time, reduced throughput, and server resource over utilization

Ensure that you structure the application in an appropriate way and deploy it onto a system or systems that provide sufficient resources

When communication must cross process or tier boundaries, consider using coarse-grained interfaces that require the minimum number of calls (preferably just one) to execute a specific task, and consider using asynchronous communication

Increased memory consumption, resulting in reduced performance, excessive cache misses (the inability to find the required data in the cache), and increased data store access

Ensure that you design an efficient and appropriate caching strategy

Increased database server processing, resulting in reduced throughput

Ensure that you choose effective types of transactions, locks, threading, and queuing approaches

Use efficient queries to minimize performance impact, and avoid fetching all of the data when only a portion is displayed

Failure to design for efficient database processing may incur unnecessary load on the database server, failure to meet performance objectives, and costs in excess of budget allocations

Increased network bandwidth consumption, resulting in delayed response times and increased load for client and server systems

Design high performance communication between tiers using the appropriate remote communication mechanism

Try to reduce the number of transitions across boundaries, and minimize the amount of data sent over the network

Batch work to reduce calls over the network

$$ Reliability: Reliability is the ability of a system to continue operating in the expected way over time

Reliability is measured as the probability that a system will not fail and that it will perform its intended function for a specified time interval

The key issues for reliability are: The system crashes or becomes unresponsive

Identify ways to detect failures and automatically initiate a failover, or redirect load to a spare or backup system

Also, consider implementing code that uses alternative systems when it detects a specific number of failed requests to an existing system

Output is inconsistent

Implement instrumentation, such as events and performance counters, that detects poor performance or failures of requests sent to external systems, and expose information through standard systems such as Event Logs, Trace files, or WMI

Log performance and auditing information about calls made to other systems and services

The system fails due to unavailability of other externalities such as systems, networks, and databases

Identify ways to handle unreliable external systems, failed communications, and failed transactions

Consider how you can take the system offline but still queue pending requests

Implement store and forward or cached message-based communication systems that allow requests to be stored when the target system is unavailable, and replayed when it is online

Consider using Windows Message Queuing or BizTalk Server to provide a reliable once-only delivery mechanism for asynchronous requests

$$ Reusability: Reusability is the probability that a component will be used in other components or scenarios to add new functionality with little or no change

Reusability minimizes the duplication of components and the implementation time

Identifying the common attributes between various components is the first step in building small reusable components for use in a larger system

The key issues for reusability are: The use of different code or components to achieve the same result in different places; for example, duplication of similar logic in multiple components, and duplication of similar logic in multiple layers or subsystems

Examine the application design to identify common functionality, and implement this functionality in separate components that you can reuse

Examine the application design to identify crosscutting concerns such as validation, logging, and authentication, and implement these functions as separate components

The use of multiple similar methods to implement tasks that have only slight variation

Instead, use parameters to vary the behavior of a single method

Using several systems to implement the same feature or function instead of sharing or reusing functionality in another system, across multiple systems, or across different subsystems within an application

Consider exposing functionality from components, layers, and subsystems through service interfaces that other layers and systems can use

Use platform agnostic data types and structures that can be accessed and understood on different platforms

$$ Scalability: Scalability is ability of a system to either handle increases in load without impact on the performance of the system, or the ability to be readily enlarged

There are two methods for improving scalability: scaling vertically (scale up), and scaling horizontally (scale out)

To scale vertically, you add more resources such as CPU, memory, and disk to a single system

To scale horizontally, you add more machines to a farm that runs the application and shares the load

The key issues for scalability are: Applications cannot handle increasing load

Consider how you can design layers and tiers for scalability, and how this affects the capability to scale up or scale out the application and the database when required

You may decide to locate logical layers on the same physical tier to reduce the number of servers required while maximizing load sharing and failover capabilities

Consider partitioning data across more than one database server to maximize scale-up opportunities and allow flexible location of data subsets

Avoid stateful components and subsystems where possible to reduce server affinity

Users incur delays in response and longer completion times

Consider how you will handle spikes in traffic and load

Consider implementing code that uses additional or alternative systems when it detects a predefined service load or a number of pending requests to an existing system

The system cannot queue excess work and process it during periods of reduced load

Implement store-and-forward or cached message-based communication systems that allow requests to be stored when the target system is unavailable, and replayed when it is online

$$ Security: Security is the capability of a system to reduce the chance of malicious or accidental actions outside of the designed usage affecting the system, and prevent disclosure or loss of information

Improving security can also increase the reliability of the system by reducing the chances of an attack succeeding and impairing system operation

Securing a system should protect assets and prevent unauthorized access to or modification of information

The factors affecting system security are confidentiality, integrity, and availability

The features used to secure systems are authentication, encryption, auditing, and logging

The key issues for security are: Spoofing of user identity

Use authentication and authorization to prevent spoofing of user identity

Identify trust boundaries, and authenticate and authorize users crossing a trust boundary

Damage caused by malicious input such as SQL injection and cross-site scripting

Protect against such damage by ensuring that you validate all input for length, range, format, and type using the constrain, reject, and sanitize principles

Encode all output you display to users

Data tampering

Partition the site into anonymous, identified, and authenticated users and use application instrumentation to log and expose behavior that can be monitored

Also use secured transport channels, and encrypt and sign sensitive data sent across the network Repudiation of user actions

Use instrumentation to audit and log all user interaction for application critical operations

Information disclosure and loss of sensitive data

Design all aspects of the application to prevent access to or exposure of sensitive system and application information

Interruption of service due to Denial of service (DoS) attacks

Consider reducing session timeouts and implementing code or hardware to detect and mitigate such attacks

$$ Supportability: Supportability is the ability of the system to provide information helpful for identifying and resolving issues when it fails to work correctly

The key issues for supportability are: Lack of diagnostic information

Identify how you will monitor system activity and performance

Consider a system monitoring application, such as Microsoft System Center

Lack of troubleshooting tools

Consider including code to create a snapshot of the system’s state to use for troubleshooting, and including custom instrumentation that can be enabled to provide detailed operational and functional reports

Consider logging and auditing information that may be useful for maintenance and debugging, such as request details or module outputs and calls to other systems and services

Lack of tracing ability

Use common components to provide tracing support in code, perhaps though Aspect Oriented Programming (AOP) techniques or dependency injection

Enable tracing in Web applications in order to troubleshoot errors

Lack of health monitoring

Consider creating a health model that defines the significant state changes that can affect application performance, and use this model to specify management instrumentation requirements

Implement instrumentation, such as events and performance counters, that detects state changes, and expose these changes through standard systems such as Event Logs, Trace files, or Windows Management Instrumentation (WMI)

Capture and report sufficient information about errors and state changes in order to enable accurate monitoring, debugging, and management

Also, consider creating management packs that administrators can use in their monitoring environments to manage the application

$$ Testability: Testability is a measure of how well system or components allow you to create test criteria and execute tests to determine if the criteria are met

Testability allows faults in a system to be isolated in a timely and effective manner

The key issues for testability are: Complex applications with many processing permutations are not tested consistently, perhaps because automated or granular testing cannot be performed if the application has a monolithic design

Design systems to be modular to support testing

Provide instrumentation or implement probes for testing, mechanisms to debug output, and ways to specify inputs easily

Design components that have high cohesion and low coupling to allow testability of components in isolation from the rest of the system

Lack of test planning

Start testing early during the development life cycle

Use mock objects during testing, and construct simple, structured test solutions

Poor test coverage, for both manual and automated tests

Consider how you can automate user interaction tests, and how you can maximize test and code coverage

Input and output inconsistencies; for the same input, the output is not the same and the output does not fully cover the output domain even when all known variations of input are provided

Consider how to make it easy to specify and understand system inputs and outputs to facilitate the construction of test cases

$$ Usability: User experience The application interfaces must be designed with the user and consumer in mind so that they are intuitive to use, can be localized and globalized, provide access for disabled users, and provide a good overall user experience

The key issues for user experience and usability are: Too much interaction (an excessive number of clicks) required for a task

Ensure you design the screen and input flows and user interaction patterns to maximize ease of use

Incorrect flow of steps in multistep interfaces

Consider incorporating workflows where appropriate to simplify multistep operations

Data elements and controls are poorly grouped

Choose appropriate control types (such as option groups and check boxes) and lay out controls and content using the accepted UI design patterns

Feedback to the user is poor, especially for errors and exceptions, and the application is unresponsive

Consider implementing technologies and techniques that provide maximum user interactivity, such as Asynchronous JavaScript and XML (AJAX) in Web pages and client-side input validation

Use asynchronous techniques for background tasks, and tasks such as populating controls or performing long-running tasks

$$ Agility: The ability of a system to both be flexible and undergo change rapidly

$$ Flexibility: The ease with which a system or component can be modified for use in applications or environments, other than those for which it was specifically designed

$$ Interoperability: The ability of two or more systems or components to exchange information and use the information that has been exchanged

$$ Maintainability: The aptitude of a system to undergo repair and evolution

The ease with which a software system or component can be modified to correct faults, improve performance or other attributes, or adapt to a changed environment

(2) The ease with which a hardware system or component can be retained in, or restored to, a state in which it can perform its required functions

$$ Performance: The responsiveness of the system—that is, the time required to respond to stimuli (events) or the number of events processed in some interval of time

Performance qualities are often expressed by the number of transactions per unit time, or by the amount of time that it takes to complete a transaction with the system

$$ Reliability: The ability of the system to keep operating over time

Reliability is usually measured by mean time to failure

$$ Reusability: The degree to which a software module or other work product can be used in more than one computing program or software system

This is typically in the form of reusing software that is an encapsulated unit of functionality

$$ Scalability: The ability to maintain or improve performance while system demand increases

$$ Security: A measure of the system's ability to resist unauthorized attempts at usage and denial of service, while still providing its services to legitimate users

Security is categorized in terms of the types of threats that might be made to the system

$$ Supportability: The ease with which a software system can be operationally maintained

$$ Testability: The degree to which a system or component facilitates the establishment of test criteria and the performance of tests to determine whether those criteria have been met

$$ Usability: The measure of a user's ability to utilize a system effectively

The ease with which a user can learn to operate, prepare inputs for, and interpret outputs of a system or component

A measure of how well users can take advantage of some system functionality

Usability is different from utility, which is a measure of whether that functionality does what is needed

$$ Reliability: Measure if product is reliable enough to sustain in any condition

Should give consistently correct results

Product reliability is measured in terms of working of project under different working environment and different conditions

$$ Maintainability: Different versions of the product should be easy to maintain

For development it should be easy to add code to existing system, should be easy to upgrade for new features and new technologies time to time

Maintenance should be cost effective and easy

System be easy to maintain and correcting defects or making a change in the software

$$ Usability: This can be measured in terms of ease of use

Application should be user friendly

Should be easy to learn

Navigation should be simple

The system must be: Easy to use for input preparation, operation, and interpretation of output

Provide consistent user interface standards or conventions with our other frequently used systems

Easy for new or infrequent users to learn to use the system

$$ Portability: This can be measured in terms of Costing issues related to porting, Technical issues related to porting, Behavioral issues related to porting

$$ Correctness: Application should be correct in terms of its functionality, calculations used internally and the navigation should be correct

This means application should adhere to functional requirements

$$ Efficiency: To Major system quality attribute

Measured in terms of time required to complete any task given to the system

For example system should utilize processor capacity, disk space and memory efficiently

If system is using all the available resources then user will get degraded performance failing the system for efficiency

If system is not efficient then it can not be used in real time applications

$$ Security: Integrity comes with security

System integrity or security should be sufficient to prevent unauthorized access to system functions, preventing information loss, ensure that the software is protected from virus infection, and protecting the privacy of data entered into the system

$$ Testability: System should be easy to test and find defects

If required should be easy to divide in different modules for testing

$$ Flexibility: Should be flexible enough to modify

Adaptable to other products with which it needs interaction

Should be easy to interface with other standard 3rd party components

$$ Reusability: Software reuse is a good cost efficient and time saving development way

Different code libraries classes should be generic enough to use easily in different application modules

Dividing application into different modules so that modules can be reused across the application

$$ Interoperability: Interoperability of one system to another should be easy for product to exchange data or services with other systems

Different system modules should work on different operating system platforms, different databases and protocols conditions

$$ Product revision: ability to undergo changes $$ Maintainability: the effort required to locate and fix a fault in the program within its operating environment, $$ Flexibility: the ease of making changes required by changes in the operating environment $$ Testability: the ease of testing the program, to ensure that it is error-free and meets its specification $$ Product transition: adaptability to new environments $$ Portability: the effort required to transfer a program from one environment to another $$ Reusability: the ease of reusing software in a different context $$ Interoperability: the effort required to couple the system to another system Product operations: its operation characteristics $$ Correctness: the extent to which a program fulfils its specification, $$ Reliability: the systems ability not to fail), $$ Efficiency: further categorized into execution efficiency and storage efficiency and generally meaning the use of resources, e

g

processor time, storage, $$ Integrity: the protection of the program from unauthorized access) and usability (the ease of the software $$ Usability: How well (easily, reliably, efficiently) can I use it as-is? $$ Maintainability: How easy is it to understand, modify and retest? $$ Portability: Can I still use it if I change my environment? $$ Portability: Code possesses the characteristic portability to the extent that it can be operated easily and well on computer configurations other than its current one

$$ Reliability: Code possesses the characteristic reliability to the extent that it can be expected to perform its intended functions satisfactorily

$$ Efficiency: Code possesses the characteristic efficiency to the extent that it fulfills its purpose without waste of resources

$$ Usability: Code possesses the characteristic usability to the extent that it is reliable, efficient and human-engineered

$$ Testability: Code possesses the characteristic testability to the extent that it facilitates the establishment of verification criteria and supports evaluation of its performance

$$ Understandability: Code possesses the characteristic understandability to the extent that its purpose is clear to the inspector

$$ Flexibility: Code possesses the characteristic modifiability to the extent that it facilitates the incorporation of changes, once the nature of the desired change has been determined

$$ Functionality: which may include feature sets, capabilities and security $$ Usability: which may include human factors, aesthetics, consistency in the user interface, online and context-sensitive help, wizards and agents, user documentation, and training materials $$ Reliability: which may include frequency and severity of failure, recoverability, predictability, accuracy, and mean time between failure (MTBF) $$ Performance: - imposes conditions on functional requirements such as speed, efficiency, availability, accuracy, throughput, response time, recovery time, and resource usage $$ Supportability: - which may include testability, extensibility, adaptability, maintainability, compatibility, configurability, serviceability, installability, localizability (internationalization) $$ Functionality: A set of attributes that relate to the existence of a set of functions and their specified properties

The functions are those that satisfy stated or implied needs

$$ Suitability: Attribute of software that relates to the presence and appropriateness of a set of functions for specified tasks

$$ Accuracy: Attributes of software that bare on the provision of right or agreed results or effects

$$ Security: Attributes of software that relate to its ability to prevent unauthorized access, whether accidental or deliberate, to programs and data

$$ Interoperability: Attributes of software that relate to its ability to interact with specified systems

$$ Compliance: Attributes of software that make the software adhere to application related standards or conventions or regulations in laws and similar prescriptions

$$ Reliability: A set of attributes that relate to the capability of software to maintain its level of performance under stated conditions for a stated period of time

Maturity: Attributes of software that relate to the frequency of failure by faults in the software

Fault tolerance: Attributes of software that relate to its ability to maintain a specified level of performance in cases of software faults or of infringement of its specified interface

Recoverability: Attributes of software that relate to the capability to re-establish its level of performance and recover the data directly affected in case of a failure and on the time and effort needed for it

Compliance: See above

$$ Usability: A set of attributes that relate to the effort needed for use, and on the individual assessment of such use, by a stated or implied set of users

Understandability: Attributes of software that relate to the users' effort for recognizing the logical concept and its applicability

Learnability: Attributes of software that relate to the users' effort for learning its application (for example, operation control, input, output)

Operability: Attributes of software that relate to the users' effort for operation and operation control

Attractiveness: - Compliance: Attributes of software that make the software adhere to application related standards or conventions or regulations in laws and similar prescriptions

$$ Efficiency: A set of attributes that relate to the relationship between the level of performance of the software and the amount of resources used, under stated conditions

Time behavior: Attributes of software that relate to response and processing times and on throughput rates in performing its function

Resource behavior: Attributes of software that relate to the amount of resources used and the duration of such use in performing its function

Compliance: See above

$$ Maintainability: A set of attributes that relate to the effort needed to make specified modifications

Analyzability: Attributes of software that relate to the effort needed for diagnosis of deficiencies or causes of failures, or for identification of parts to be modified

Changeability: Attributes of software that relate to the effort needed for modification, fault removal or for environmental change

Stability: Attributes of software that relate to the risk of unexpected effect of modifications

Testability: Attributes of software that relate to the effort needed for validating the modified software

Compliance: See above

$$ Portability: A set of attributes that relate to the ability of software to be transferred from one environment to another

Adaptability: Attributes of software that relate to on the opportunity for its adaptation to different specified environments without applying other actions or means than those provided for this purpose for the software considered

Installability: Attributes of software that relate to the effort needed to install the software in a specified environment

Conformance: Attributes of software that make the software adhere to standards or conventions relating to portability

Replaceability: Attributes of software that relate to the opportunity and effort of using it in the place of specified other software in the environment of that software

Transcendental view, where quality is recognized but not defined

The transcendental view is a subjective and non quantifiable of defining software quality

It often results in software that transcends customer expectations

User view on quality or “fitness for purpose” takes the starting point in software that meets the users’ needs

Reliability (failure rate, MTBF), Performance/Efficiency (time to perform a task), Maintainability and Usability are issues within this view

Manufacturing view on quality focuses on conformance to specification and the organizations capacity to produce software according to the software process

Here product quality is achieved through process quality

Waste reduction, Zero defect, Right the first time (defect count and fault rates, staff effort rework costs) are concepts usually found within this view

Product view on quality usually specifies that the characteristics of product are defined by the characteristics of its subparts, e

g

size, complexity, and test coverage

Module complexity measures, Design & code measures etc

Value based view on quality measures and produces value for money by balancing requirements, budget and time, cost & price, deliver dates (lead time, calendar time), productivity etc

$$ Usability: Usability includes looking at, capturing, and stating requirements based around user interface issues, e

g

issues such as accessibility, interface aesthetics, and consistency within the user interface

$$ Reliability: Reliability includes aspects such as availability, accuracy, and recoverability, for example recoverability of the system from shut-down failure

$$ Performance: Performance involves issues such as throughput of information, system response time (which also relates to usability), recovery time, and startup time

$$ Supportability : This is a general bucket of requirements that address supporting the software: for example testability, adaptability, maintainability, compatibility, configurability, installability, scalability, localizability, and so on

$$ Product: revision The product revision perspective identifies quality factors that influence the ability to change the software product, these factors are:- $$ Maintainability, the ability to find and fix a defect

$$ Flexibility, the ability to make changes required as dictated by the business

$$ Testability, the ability to Validate the software requirements

$$ Portability: the ability to transfer the software from one environment to another

$$ Reusability: the ease of using existing software components in a different context

$$ Interoperability: the extent, or ease, to which software components work together

$$ Reliability: the extent to which the system fails

$$ Efficiency: system resource (including cpu, disk, memory, network) usage

$$ Integrity: protection from unauthorized access

$$ Usability: ease of use

$$ Maintainability: ease of modification, ease of retesting

$$ Portability: ease of changing software to accommodate a new environment

Portability: the extent to which the software will work under different computer configurations (i

e

operating systems, databases etc

)

$$ Reliability: the extent to which the software performs as required, i

e

the absence of defects

$$ Efficiency: optimum use of system resources during correct execution

$$ Usability: ease of use

$$ Testability: ease of validation, that the software meets the requirements

$$ Understandability: the extent to which the software is easily comprehended with regard to purpose and structure

$$ Flexibility: the ease of changing the software to meet revised requirements $$ Maintainability : Effort required to locate and fix a fault in the program within its operating environment

$$ Flexibility : The ease of making changes required as dictated by business by changes in the operating environment

$$ Testability : The ease of testing program to ensure that it is error-free and meets its specification, i

e, validating the software requirements

$$ Product Transition : This identifies quality factors that influence the ability to adapt the software to new environments

$$ Portability : The effort required to transfer a program from one environment to another

$$ Re-usability : The ease of reusing software in a different context

$$ Interoperability: The effort required to couple the system to another system

Product Operations : This identifies quality factors that influence the extent to which the software fulfills its specification

$$ Correctness : The extent to which a functionality matches its specification

$$ Reliability : The systems ability not to fail/ the extent to which the system fails

$$ Efficiency : Further categorized into execution efficiency and storage efficiency and generally means the usage of system resources, example: processor time, memory

$$ Integrity : The protection of program from unauthorized access

$$ Usability : The ease of using software
